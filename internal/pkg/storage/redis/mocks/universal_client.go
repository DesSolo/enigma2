// Code generated by mockery v2.51.1. DO NOT EDIT.

package mocks

import (
	context "context"

	redis "github.com/redis/go-redis/v9"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// UniversalClient is an autogenerated mock type for the UniversalClient type
type UniversalClient struct {
	mock.Mock
}

// ACLCat provides a mock function with given fields: ctx
func (_m *UniversalClient) ACLCat(ctx context.Context) *redis.StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLCat")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ACLCatArgs provides a mock function with given fields: ctx, options
func (_m *UniversalClient) ACLCatArgs(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for ACLCatArgs")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ACLCatArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ACLDelUser provides a mock function with given fields: ctx, username
func (_m *UniversalClient) ACLDelUser(ctx context.Context, username string) *redis.IntCmd {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for ACLDelUser")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ACLDryRun provides a mock function with given fields: ctx, username, command
func (_m *UniversalClient) ACLDryRun(ctx context.Context, username string, command ...interface{}) *redis.StringCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, username)
	_ca = append(_ca, command...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ACLDryRun")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, username, command...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ACLList provides a mock function with given fields: ctx
func (_m *UniversalClient) ACLList(ctx context.Context) *redis.StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLList")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ACLLog provides a mock function with given fields: ctx, count
func (_m *UniversalClient) ACLLog(ctx context.Context, count int64) *redis.ACLLogCmd {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for ACLLog")
	}

	var r0 *redis.ACLLogCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *redis.ACLLogCmd); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ACLLogCmd)
		}
	}

	return r0
}

// ACLLogReset provides a mock function with given fields: ctx
func (_m *UniversalClient) ACLLogReset(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLLogReset")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ACLSetUser provides a mock function with given fields: ctx, username, rules
func (_m *UniversalClient) ACLSetUser(ctx context.Context, username string, rules ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(rules))
	for _i := range rules {
		_va[_i] = rules[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, username)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ACLSetUser")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StatusCmd); ok {
		r0 = rf(ctx, username, rules...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// AddHook provides a mock function with given fields: _a0
func (_m *UniversalClient) AddHook(_a0 redis.Hook) {
	_m.Called(_a0)
}

// Append provides a mock function with given fields: ctx, key, value
func (_m *UniversalClient) Append(ctx context.Context, key string, value string) *redis.IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BFAdd provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) BFAdd(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for BFAdd")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// BFCard provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BFExists provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) BFExists(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for BFExists")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// BFInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFInfo(ctx context.Context, key string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfo")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInfoArg provides a mock function with given fields: ctx, key, option
func (_m *UniversalClient) BFInfoArg(ctx context.Context, key string, option string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key, option)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoArg")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key, option)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInfoCapacity provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFInfoCapacity(ctx context.Context, key string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoCapacity")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInfoExpansion provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFInfoExpansion(ctx context.Context, key string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoExpansion")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInfoFilters provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFInfoFilters(ctx context.Context, key string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoFilters")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInfoItems provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFInfoItems(ctx context.Context, key string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoItems")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInfoSize provides a mock function with given fields: ctx, key
func (_m *UniversalClient) BFInfoSize(ctx context.Context, key string) *redis.BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoSize")
	}

	var r0 *redis.BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BFInfoCmd)
		}
	}

	return r0
}

// BFInsert provides a mock function with given fields: ctx, key, options, elements
func (_m *UniversalClient) BFInsert(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BFInsert")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.BFInsertOptions, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, options, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// BFLoadChunk provides a mock function with given fields: ctx, key, iterator, data
func (_m *UniversalClient) BFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, key, iterator, data)

	if len(ret) == 0 {
		panic("no return value specified for BFLoadChunk")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, iterator, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BFMAdd provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) BFMAdd(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BFMAdd")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// BFMExists provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) BFMExists(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BFMExists")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// BFReserve provides a mock function with given fields: ctx, key, errorRate, capacity
func (_m *UniversalClient) BFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, errorRate, capacity)

	if len(ret) == 0 {
		panic("no return value specified for BFReserve")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, capacity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BFReserveExpansion provides a mock function with given fields: ctx, key, errorRate, capacity, expansion
func (_m *UniversalClient) BFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, errorRate, capacity, expansion)

	if len(ret) == 0 {
		panic("no return value specified for BFReserveExpansion")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, capacity, expansion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BFReserveNonScaling provides a mock function with given fields: ctx, key, errorRate, capacity
func (_m *UniversalClient) BFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, errorRate, capacity)

	if len(ret) == 0 {
		panic("no return value specified for BFReserveNonScaling")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, capacity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BFReserveWithArgs provides a mock function with given fields: ctx, key, options
func (_m *UniversalClient) BFReserveWithArgs(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for BFReserveWithArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.BFReserveOptions) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BFScanDump provides a mock function with given fields: ctx, key, iterator
func (_m *UniversalClient) BFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	ret := _m.Called(ctx, key, iterator)

	if len(ret) == 0 {
		panic("no return value specified for BFScanDump")
	}

	var r0 *redis.ScanDumpCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.ScanDumpCmd); ok {
		r0 = rf(ctx, key, iterator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanDumpCmd)
		}
	}

	return r0
}

// BLMPop provides a mock function with given fields: ctx, timeout, direction, count, keys
func (_m *UniversalClient) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout, direction, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLMPop")
	}

	var r0 *redis.KeyValuesCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, string, int64, ...string) *redis.KeyValuesCmd); ok {
		r0 = rf(ctx, timeout, direction, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.KeyValuesCmd)
		}
	}

	return r0
}

// BLMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos, timeout
func (_m *UniversalClient) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BLMove")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// BLPop provides a mock function with given fields: ctx, timeout, keys
func (_m *UniversalClient) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPop provides a mock function with given fields: ctx, timeout, keys
func (_m *UniversalClient) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BRPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPopLPush provides a mock function with given fields: ctx, source, destination, timeout
func (_m *UniversalClient) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BRPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// BZMPop provides a mock function with given fields: ctx, timeout, order, count, keys
func (_m *UniversalClient) BZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout, order, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZMPop")
	}

	var r0 *redis.ZSliceWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, string, int64, ...string) *redis.ZSliceWithKeyCmd); ok {
		r0 = rf(ctx, timeout, order, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceWithKeyCmd)
		}
	}

	return r0
}

// BZPopMax provides a mock function with given fields: ctx, timeout, keys
func (_m *UniversalClient) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMax")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BZPopMin provides a mock function with given fields: ctx, timeout, keys
func (_m *UniversalClient) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMin")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BgRewriteAOF provides a mock function with given fields: ctx
func (_m *UniversalClient) BgRewriteAOF(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgRewriteAOF")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BgSave provides a mock function with given fields: ctx
func (_m *UniversalClient) BgSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BitCount provides a mock function with given fields: ctx, key, bitCount
func (_m *UniversalClient) BitCount(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
	ret := _m.Called(ctx, key, bitCount)

	if len(ret) == 0 {
		panic("no return value specified for BitCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.BitCount) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitField provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) BitField(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitField")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// BitFieldRO provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) BitFieldRO(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitFieldRO")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// BitOpAnd provides a mock function with given fields: ctx, destKey, keys
func (_m *UniversalClient) BitOpAnd(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpAnd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpNot provides a mock function with given fields: ctx, destKey, key
func (_m *UniversalClient) BitOpNot(ctx context.Context, destKey string, key string) *redis.IntCmd {
	ret := _m.Called(ctx, destKey, key)

	if len(ret) == 0 {
		panic("no return value specified for BitOpNot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpOr provides a mock function with given fields: ctx, destKey, keys
func (_m *UniversalClient) BitOpOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpOr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpXor provides a mock function with given fields: ctx, destKey, keys
func (_m *UniversalClient) BitOpXor(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpXor")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitPos provides a mock function with given fields: ctx, key, bit, pos
func (_m *UniversalClient) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitPosSpan provides a mock function with given fields: ctx, key, bit, start, end, span
func (_m *UniversalClient) BitPosSpan(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd {
	ret := _m.Called(ctx, key, bit, start, end, span)

	if len(ret) == 0 {
		panic("no return value specified for BitPosSpan")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int8, int64, int64, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bit, start, end, span)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// CFAdd provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) CFAdd(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFAdd")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// CFAddNX provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) CFAddNX(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFAddNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// CFCount provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) CFCount(ctx context.Context, key string, element interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// CFDel provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) CFDel(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFDel")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// CFExists provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) CFExists(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFExists")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// CFInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) CFInfo(ctx context.Context, key string) *redis.CFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for CFInfo")
	}

	var r0 *redis.CFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.CFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CFInfoCmd)
		}
	}

	return r0
}

// CFInsert provides a mock function with given fields: ctx, key, options, elements
func (_m *UniversalClient) CFInsert(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CFInsert")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.CFInsertOptions, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, options, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// CFInsertNX provides a mock function with given fields: ctx, key, options, elements
func (_m *UniversalClient) CFInsertNX(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CFInsertNX")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.CFInsertOptions, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, options, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// CFLoadChunk provides a mock function with given fields: ctx, key, iterator, data
func (_m *UniversalClient) CFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, key, iterator, data)

	if len(ret) == 0 {
		panic("no return value specified for CFLoadChunk")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, iterator, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CFMExists provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) CFMExists(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CFMExists")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// CFReserve provides a mock function with given fields: ctx, key, capacity
func (_m *UniversalClient) CFReserve(ctx context.Context, key string, capacity int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, capacity)

	if len(ret) == 0 {
		panic("no return value specified for CFReserve")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, capacity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CFReserveBucketSize provides a mock function with given fields: ctx, key, capacity, bucketsize
func (_m *UniversalClient) CFReserveBucketSize(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, capacity, bucketsize)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveBucketSize")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, capacity, bucketsize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CFReserveExpansion provides a mock function with given fields: ctx, key, capacity, expansion
func (_m *UniversalClient) CFReserveExpansion(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, capacity, expansion)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveExpansion")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, capacity, expansion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CFReserveMaxIterations provides a mock function with given fields: ctx, key, capacity, maxiterations
func (_m *UniversalClient) CFReserveMaxIterations(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, capacity, maxiterations)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveMaxIterations")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, capacity, maxiterations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CFReserveWithArgs provides a mock function with given fields: ctx, key, options
func (_m *UniversalClient) CFReserveWithArgs(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveWithArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.CFReserveOptions) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CFScanDump provides a mock function with given fields: ctx, key, iterator
func (_m *UniversalClient) CFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	ret := _m.Called(ctx, key, iterator)

	if len(ret) == 0 {
		panic("no return value specified for CFScanDump")
	}

	var r0 *redis.ScanDumpCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.ScanDumpCmd); ok {
		r0 = rf(ctx, key, iterator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanDumpCmd)
		}
	}

	return r0
}

// CMSIncrBy provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) CMSIncrBy(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CMSIncrBy")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// CMSInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) CMSInfo(ctx context.Context, key string) *redis.CMSInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for CMSInfo")
	}

	var r0 *redis.CMSInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.CMSInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CMSInfoCmd)
		}
	}

	return r0
}

// CMSInitByDim provides a mock function with given fields: ctx, key, width, height
func (_m *UniversalClient) CMSInitByDim(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, width, height)

	if len(ret) == 0 {
		panic("no return value specified for CMSInitByDim")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, width, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CMSInitByProb provides a mock function with given fields: ctx, key, errorRate, probability
func (_m *UniversalClient) CMSInitByProb(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, errorRate, probability)

	if len(ret) == 0 {
		panic("no return value specified for CMSInitByProb")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, probability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CMSMerge provides a mock function with given fields: ctx, destKey, sourceKeys
func (_m *UniversalClient) CMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(sourceKeys))
	for _i := range sourceKeys {
		_va[_i] = sourceKeys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CMSMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StatusCmd); ok {
		r0 = rf(ctx, destKey, sourceKeys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CMSMergeWithWeight provides a mock function with given fields: ctx, destKey, sourceKeys
func (_m *UniversalClient) CMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd {
	ret := _m.Called(ctx, destKey, sourceKeys)

	if len(ret) == 0 {
		panic("no return value specified for CMSMergeWithWeight")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, destKey, sourceKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// CMSQuery provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) CMSQuery(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CMSQuery")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// ClientGetName provides a mock function with given fields: ctx
func (_m *UniversalClient) ClientGetName(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientGetName")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientID provides a mock function with given fields: ctx
func (_m *UniversalClient) ClientID(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientInfo provides a mock function with given fields: ctx
func (_m *UniversalClient) ClientInfo(ctx context.Context) *redis.ClientInfoCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientInfo")
	}

	var r0 *redis.ClientInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.ClientInfoCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClientInfoCmd)
		}
	}

	return r0
}

// ClientKill provides a mock function with given fields: ctx, ipPort
func (_m *UniversalClient) ClientKill(ctx context.Context, ipPort string) *redis.StatusCmd {
	ret := _m.Called(ctx, ipPort)

	if len(ret) == 0 {
		panic("no return value specified for ClientKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, ipPort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClientKillByFilter provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) ClientKillByFilter(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientKillByFilter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientList provides a mock function with given fields: ctx
func (_m *UniversalClient) ClientList(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientList")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientPause provides a mock function with given fields: ctx, dur
func (_m *UniversalClient) ClientPause(ctx context.Context, dur time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, dur)

	if len(ret) == 0 {
		panic("no return value specified for ClientPause")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, dur)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ClientUnblock provides a mock function with given fields: ctx, id
func (_m *UniversalClient) ClientUnblock(ctx context.Context, id int64) *redis.IntCmd {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for ClientUnblock")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientUnblockWithError provides a mock function with given fields: ctx, id
func (_m *UniversalClient) ClientUnblockWithError(ctx context.Context, id int64) *redis.IntCmd {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for ClientUnblockWithError")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientUnpause provides a mock function with given fields: ctx
func (_m *UniversalClient) ClientUnpause(ctx context.Context) *redis.BoolCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientUnpause")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.BoolCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Close provides a mock function with no fields
func (_m *UniversalClient) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClusterAddSlots provides a mock function with given fields: ctx, slots
func (_m *UniversalClient) ClusterAddSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *redis.StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterAddSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *UniversalClient) ClusterAddSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterCountFailureReports provides a mock function with given fields: ctx, nodeID
func (_m *UniversalClient) ClusterCountFailureReports(ctx context.Context, nodeID string) *redis.IntCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountFailureReports")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterCountKeysInSlot provides a mock function with given fields: ctx, slot
func (_m *UniversalClient) ClusterCountKeysInSlot(ctx context.Context, slot int) *redis.IntCmd {
	ret := _m.Called(ctx, slot)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountKeysInSlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int) *redis.IntCmd); ok {
		r0 = rf(ctx, slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterDelSlots provides a mock function with given fields: ctx, slots
func (_m *UniversalClient) ClusterDelSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *redis.StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterDelSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *UniversalClient) ClusterDelSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterFailover provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterFailover(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterFailover")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterForget provides a mock function with given fields: ctx, nodeID
func (_m *UniversalClient) ClusterForget(ctx context.Context, nodeID string) *redis.StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterForget")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterGetKeysInSlot provides a mock function with given fields: ctx, slot, count
func (_m *UniversalClient) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, slot, count)

	if len(ret) == 0 {
		panic("no return value specified for ClusterGetKeysInSlot")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, slot, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterInfo provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterInfo(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterInfo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterKeySlot provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ClusterKeySlot(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ClusterKeySlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterLinks provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterLinks(ctx context.Context) *redis.ClusterLinksCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterLinks")
	}

	var r0 *redis.ClusterLinksCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.ClusterLinksCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterLinksCmd)
		}
	}

	return r0
}

// ClusterMeet provides a mock function with given fields: ctx, host, port
func (_m *UniversalClient) ClusterMeet(ctx context.Context, host string, port string) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMeet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterMyID provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterMyID(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMyID")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterMyShardID provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterMyShardID(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMyShardID")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterNodes provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterNodes(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNodes")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterReplicate provides a mock function with given fields: ctx, nodeID
func (_m *UniversalClient) ClusterReplicate(ctx context.Context, nodeID string) *redis.StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterReplicate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetHard provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterResetHard(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetHard")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetSoft provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterResetSoft(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetSoft")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSaveConfig provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterSaveConfig(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSaveConfig")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterShards provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterShards(ctx context.Context) *redis.ClusterShardsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterShards")
	}

	var r0 *redis.ClusterShardsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.ClusterShardsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterShardsCmd)
		}
	}

	return r0
}

// ClusterSlaves provides a mock function with given fields: ctx, nodeID
func (_m *UniversalClient) ClusterSlaves(ctx context.Context, nodeID string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlaves")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterSlots provides a mock function with given fields: ctx
func (_m *UniversalClient) ClusterSlots(ctx context.Context) *redis.ClusterSlotsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlots")
	}

	var r0 *redis.ClusterSlotsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.ClusterSlotsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterSlotsCmd)
		}
	}

	return r0
}

// Command provides a mock function with given fields: ctx
func (_m *UniversalClient) Command(ctx context.Context) *redis.CommandsInfoCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Command")
	}

	var r0 *redis.CommandsInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.CommandsInfoCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CommandsInfoCmd)
		}
	}

	return r0
}

// CommandGetKeys provides a mock function with given fields: ctx, commands
func (_m *UniversalClient) CommandGetKeys(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, commands...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommandGetKeys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, commands...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// CommandGetKeysAndFlags provides a mock function with given fields: ctx, commands
func (_m *UniversalClient) CommandGetKeysAndFlags(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, commands...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommandGetKeysAndFlags")
	}

	var r0 *redis.KeyFlagsCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.KeyFlagsCmd); ok {
		r0 = rf(ctx, commands...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.KeyFlagsCmd)
		}
	}

	return r0
}

// CommandList provides a mock function with given fields: ctx, filter
func (_m *UniversalClient) CommandList(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for CommandList")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.FilterBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ConfigGet provides a mock function with given fields: ctx, parameter
func (_m *UniversalClient) ConfigGet(ctx context.Context, parameter string) *redis.MapStringStringCmd {
	ret := _m.Called(ctx, parameter)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGet")
	}

	var r0 *redis.MapStringStringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.MapStringStringCmd); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringStringCmd)
		}
	}

	return r0
}

// ConfigResetStat provides a mock function with given fields: ctx
func (_m *UniversalClient) ConfigResetStat(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigResetStat")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigRewrite provides a mock function with given fields: ctx
func (_m *UniversalClient) ConfigRewrite(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigRewrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigSet provides a mock function with given fields: ctx, parameter, value
func (_m *UniversalClient) ConfigSet(ctx context.Context, parameter string, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, parameter, value)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, parameter, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Copy provides a mock function with given fields: ctx, sourceKey, destKey, db, replace
func (_m *UniversalClient) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
	ret := _m.Called(ctx, sourceKey, destKey, db, replace)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, bool) *redis.IntCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, db, replace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DBSize provides a mock function with given fields: ctx
func (_m *UniversalClient) DBSize(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DBSize")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DebugObject provides a mock function with given fields: ctx, key
func (_m *UniversalClient) DebugObject(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for DebugObject")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Decr provides a mock function with given fields: ctx, key
func (_m *UniversalClient) Decr(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Decr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DecrBy provides a mock function with given fields: ctx, key, decrement
func (_m *UniversalClient) DecrBy(ctx context.Context, key string, decrement int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, decrement)

	if len(ret) == 0 {
		panic("no return value specified for DecrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Del provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Do provides a mock function with given fields: ctx, args
func (_m *UniversalClient) Do(ctx context.Context, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// Dump provides a mock function with given fields: ctx, key
func (_m *UniversalClient) Dump(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Dump")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Echo provides a mock function with given fields: ctx, message
func (_m *UniversalClient) Echo(ctx context.Context, message interface{}) *redis.StringCmd {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for Echo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Eval provides a mock function with given fields: ctx, script, keys, args
func (_m *UniversalClient) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// EvalRO provides a mock function with given fields: ctx, script, keys, args
func (_m *UniversalClient) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalRO")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// EvalSha provides a mock function with given fields: ctx, sha1, keys, args
func (_m *UniversalClient) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalSha")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// EvalShaRO provides a mock function with given fields: ctx, sha1, keys, args
func (_m *UniversalClient) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalShaRO")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// Exists provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) Exists(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) Expire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *UniversalClient) ExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireGT provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) ExpireGT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireGT")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireLT provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) ExpireLT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireLT")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireNX provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) ExpireNX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireTime provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ExpireTime")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// ExpireXX provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) ExpireXX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// FCall provides a mock function with given fields: ctx, function, keys, args
func (_m *UniversalClient) FCall(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCall")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// FCallRO provides a mock function with given fields: ctx, function, keys, args
func (_m *UniversalClient) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCallRO")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// FCallRo provides a mock function with given fields: ctx, function, keys, args
func (_m *UniversalClient) FCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCallRo")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// FTAggregate provides a mock function with given fields: ctx, index, query
func (_m *UniversalClient) FTAggregate(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTAggregate")
	}

	var r0 *redis.MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.MapStringInterfaceCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringInterfaceCmd)
		}
	}

	return r0
}

// FTAggregateWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *UniversalClient) FTAggregateWithArgs(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTAggregateWithArgs")
	}

	var r0 *redis.AggregateCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.FTAggregateOptions) *redis.AggregateCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.AggregateCmd)
		}
	}

	return r0
}

// FTAliasAdd provides a mock function with given fields: ctx, index, alias
func (_m *UniversalClient) FTAliasAdd(ctx context.Context, index string, alias string) *redis.StatusCmd {
	ret := _m.Called(ctx, index, alias)

	if len(ret) == 0 {
		panic("no return value specified for FTAliasAdd")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTAliasDel provides a mock function with given fields: ctx, alias
func (_m *UniversalClient) FTAliasDel(ctx context.Context, alias string) *redis.StatusCmd {
	ret := _m.Called(ctx, alias)

	if len(ret) == 0 {
		panic("no return value specified for FTAliasDel")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTAliasUpdate provides a mock function with given fields: ctx, index, alias
func (_m *UniversalClient) FTAliasUpdate(ctx context.Context, index string, alias string) *redis.StatusCmd {
	ret := _m.Called(ctx, index, alias)

	if len(ret) == 0 {
		panic("no return value specified for FTAliasUpdate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTAlter provides a mock function with given fields: ctx, index, skipInitialScan, definition
func (_m *UniversalClient) FTAlter(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, index, skipInitialScan, definition)

	if len(ret) == 0 {
		panic("no return value specified for FTAlter")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, []interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, skipInitialScan, definition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTConfigGet provides a mock function with given fields: ctx, option
func (_m *UniversalClient) FTConfigGet(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd {
	ret := _m.Called(ctx, option)

	if len(ret) == 0 {
		panic("no return value specified for FTConfigGet")
	}

	var r0 *redis.MapMapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.MapMapStringInterfaceCmd); ok {
		r0 = rf(ctx, option)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapMapStringInterfaceCmd)
		}
	}

	return r0
}

// FTConfigSet provides a mock function with given fields: ctx, option, value
func (_m *UniversalClient) FTConfigSet(ctx context.Context, option string, value interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, option, value)

	if len(ret) == 0 {
		panic("no return value specified for FTConfigSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, option, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTCreate provides a mock function with given fields: ctx, index, options, schema
func (_m *UniversalClient) FTCreate(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd {
	_va := make([]interface{}, len(schema))
	for _i := range schema {
		_va[_i] = schema[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, index, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FTCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.FTCreateOptions, ...*redis.FieldSchema) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, options, schema...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTCursorDel provides a mock function with given fields: ctx, index, cursorId
func (_m *UniversalClient) FTCursorDel(ctx context.Context, index string, cursorId int) *redis.StatusCmd {
	ret := _m.Called(ctx, index, cursorId)

	if len(ret) == 0 {
		panic("no return value specified for FTCursorDel")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, cursorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTCursorRead provides a mock function with given fields: ctx, index, cursorId, count
func (_m *UniversalClient) FTCursorRead(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd {
	ret := _m.Called(ctx, index, cursorId, count)

	if len(ret) == 0 {
		panic("no return value specified for FTCursorRead")
	}

	var r0 *redis.MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *redis.MapStringInterfaceCmd); ok {
		r0 = rf(ctx, index, cursorId, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringInterfaceCmd)
		}
	}

	return r0
}

// FTDictAdd provides a mock function with given fields: ctx, dict, term
func (_m *UniversalClient) FTDictAdd(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, dict)
	_ca = append(_ca, term...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FTDictAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, dict, term...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// FTDictDel provides a mock function with given fields: ctx, dict, term
func (_m *UniversalClient) FTDictDel(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, dict)
	_ca = append(_ca, term...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FTDictDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, dict, term...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// FTDictDump provides a mock function with given fields: ctx, dict
func (_m *UniversalClient) FTDictDump(ctx context.Context, dict string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, dict)

	if len(ret) == 0 {
		panic("no return value specified for FTDictDump")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, dict)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// FTDropIndex provides a mock function with given fields: ctx, index
func (_m *UniversalClient) FTDropIndex(ctx context.Context, index string) *redis.StatusCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for FTDropIndex")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTDropIndexWithArgs provides a mock function with given fields: ctx, index, options
func (_m *UniversalClient) FTDropIndexWithArgs(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd {
	ret := _m.Called(ctx, index, options)

	if len(ret) == 0 {
		panic("no return value specified for FTDropIndexWithArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.FTDropIndexOptions) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTExplain provides a mock function with given fields: ctx, index, query
func (_m *UniversalClient) FTExplain(ctx context.Context, index string, query string) *redis.StringCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTExplain")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FTExplainWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *UniversalClient) FTExplainWithArgs(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTExplainWithArgs")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.FTExplainOptions) *redis.StringCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FTInfo provides a mock function with given fields: ctx, index
func (_m *UniversalClient) FTInfo(ctx context.Context, index string) *redis.FTInfoCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for FTInfo")
	}

	var r0 *redis.FTInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.FTInfoCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FTInfoCmd)
		}
	}

	return r0
}

// FTSearch provides a mock function with given fields: ctx, index, query
func (_m *UniversalClient) FTSearch(ctx context.Context, index string, query string) *redis.FTSearchCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTSearch")
	}

	var r0 *redis.FTSearchCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.FTSearchCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FTSearchCmd)
		}
	}

	return r0
}

// FTSearchWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *UniversalClient) FTSearchWithArgs(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTSearchWithArgs")
	}

	var r0 *redis.FTSearchCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.FTSearchOptions) *redis.FTSearchCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FTSearchCmd)
		}
	}

	return r0
}

// FTSpellCheck provides a mock function with given fields: ctx, index, query
func (_m *UniversalClient) FTSpellCheck(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTSpellCheck")
	}

	var r0 *redis.FTSpellCheckCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.FTSpellCheckCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FTSpellCheckCmd)
		}
	}

	return r0
}

// FTSpellCheckWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *UniversalClient) FTSpellCheckWithArgs(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTSpellCheckWithArgs")
	}

	var r0 *redis.FTSpellCheckCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FTSpellCheckCmd)
		}
	}

	return r0
}

// FTSynDump provides a mock function with given fields: ctx, index
func (_m *UniversalClient) FTSynDump(ctx context.Context, index string) *redis.FTSynDumpCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for FTSynDump")
	}

	var r0 *redis.FTSynDumpCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.FTSynDumpCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FTSynDumpCmd)
		}
	}

	return r0
}

// FTSynUpdate provides a mock function with given fields: ctx, index, synGroupId, terms
func (_m *UniversalClient) FTSynUpdate(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, index, synGroupId, terms)

	if len(ret) == 0 {
		panic("no return value specified for FTSynUpdate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, []interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, synGroupId, terms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTSynUpdateWithArgs provides a mock function with given fields: ctx, index, synGroupId, options, terms
func (_m *UniversalClient) FTSynUpdateWithArgs(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, index, synGroupId, options, terms)

	if len(ret) == 0 {
		panic("no return value specified for FTSynUpdateWithArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, *redis.FTSynUpdateOptions, []interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, index, synGroupId, options, terms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FTTagVals provides a mock function with given fields: ctx, index, field
func (_m *UniversalClient) FTTagVals(ctx context.Context, index string, field string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, index, field)

	if len(ret) == 0 {
		panic("no return value specified for FTTagVals")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, index, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// FT_List provides a mock function with given fields: ctx
func (_m *UniversalClient) FT_List(ctx context.Context) *redis.StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FT_List")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// FlushAll provides a mock function with given fields: ctx
func (_m *UniversalClient) FlushAll(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushAllAsync provides a mock function with given fields: ctx
func (_m *UniversalClient) FlushAllAsync(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAllAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDB provides a mock function with given fields: ctx
func (_m *UniversalClient) FlushDB(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDB")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDBAsync provides a mock function with given fields: ctx
func (_m *UniversalClient) FlushDBAsync(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDBAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FunctionDelete provides a mock function with given fields: ctx, libName
func (_m *UniversalClient) FunctionDelete(ctx context.Context, libName string) *redis.StringCmd {
	ret := _m.Called(ctx, libName)

	if len(ret) == 0 {
		panic("no return value specified for FunctionDelete")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, libName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionDump provides a mock function with given fields: ctx
func (_m *UniversalClient) FunctionDump(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionDump")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionFlush provides a mock function with given fields: ctx
func (_m *UniversalClient) FunctionFlush(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionFlush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionFlushAsync provides a mock function with given fields: ctx
func (_m *UniversalClient) FunctionFlushAsync(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionFlushAsync")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionKill provides a mock function with given fields: ctx
func (_m *UniversalClient) FunctionKill(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionKill")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionList provides a mock function with given fields: ctx, q
func (_m *UniversalClient) FunctionList(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for FunctionList")
	}

	var r0 *redis.FunctionListCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.FunctionListQuery) *redis.FunctionListCmd); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FunctionListCmd)
		}
	}

	return r0
}

// FunctionLoad provides a mock function with given fields: ctx, code
func (_m *UniversalClient) FunctionLoad(ctx context.Context, code string) *redis.StringCmd {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for FunctionLoad")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionLoadReplace provides a mock function with given fields: ctx, code
func (_m *UniversalClient) FunctionLoadReplace(ctx context.Context, code string) *redis.StringCmd {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for FunctionLoadReplace")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionRestore provides a mock function with given fields: ctx, libDump
func (_m *UniversalClient) FunctionRestore(ctx context.Context, libDump string) *redis.StringCmd {
	ret := _m.Called(ctx, libDump)

	if len(ret) == 0 {
		panic("no return value specified for FunctionRestore")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, libDump)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// FunctionStats provides a mock function with given fields: ctx
func (_m *UniversalClient) FunctionStats(ctx context.Context) *redis.FunctionStatsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionStats")
	}

	var r0 *redis.FunctionStatsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.FunctionStatsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FunctionStatsCmd)
		}
	}

	return r0
}

// GeoAdd provides a mock function with given fields: ctx, key, geoLocation
func (_m *UniversalClient) GeoAdd(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.GeoLocation) *redis.IntCmd); ok {
		r0 = rf(ctx, key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoDist provides a mock function with given fields: ctx, key, member1, member2, unit
func (_m *UniversalClient) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member1, member2, unit)

	if len(ret) == 0 {
		panic("no return value specified for GeoDist")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// GeoHash provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) GeoHash(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoHash")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// GeoPos provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) GeoPos(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoPos")
	}

	var r0 *redis.GeoPosCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.GeoPosCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoPosCmd)
		}
	}

	return r0
}

// GeoRadius provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *UniversalClient) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadius")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMember provides a mock function with given fields: ctx, key, member, query
func (_m *UniversalClient) GeoRadiusByMember(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMember")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMemberStore provides a mock function with given fields: ctx, key, member, query
func (_m *UniversalClient) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMemberStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoRadiusStore provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *UniversalClient) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoSearch provides a mock function with given fields: ctx, key, q
func (_m *UniversalClient) GeoSearch(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearch")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.GeoSearchQuery) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// GeoSearchLocation provides a mock function with given fields: ctx, key, q
func (_m *UniversalClient) GeoSearchLocation(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchLocation")
	}

	var r0 *redis.GeoSearchLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoSearchLocationCmd)
		}
	}

	return r0
}

// GeoSearchStore provides a mock function with given fields: ctx, key, store, q
func (_m *UniversalClient) GeoSearchStore(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, store, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoSearchStoreQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, store, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Get provides a mock function with given fields: ctx, key
func (_m *UniversalClient) Get(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetBit provides a mock function with given fields: ctx, key, offset
func (_m *UniversalClient) GetBit(ctx context.Context, key string, offset int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GetDel provides a mock function with given fields: ctx, key
func (_m *UniversalClient) GetDel(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetDel")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetEx provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) GetEx(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for GetEx")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetRange provides a mock function with given fields: ctx, key, start, end
func (_m *UniversalClient) GetRange(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
	ret := _m.Called(ctx, key, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetRange")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringCmd); ok {
		r0 = rf(ctx, key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetSet provides a mock function with given fields: ctx, key, value
func (_m *UniversalClient) GetSet(ctx context.Context, key string, value interface{}) *redis.StringCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetSet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HDel provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HDel(ctx context.Context, key string, fields ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HExists provides a mock function with given fields: ctx, key, field
func (_m *UniversalClient) HExists(ctx context.Context, key string, field string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HExists")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HExpire provides a mock function with given fields: ctx, key, expiration, fields
func (_m *UniversalClient) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpire")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HExpireAt provides a mock function with given fields: ctx, key, tm, fields
func (_m *UniversalClient) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireAt")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HExpireAtWithArgs provides a mock function with given fields: ctx, key, tm, expirationArgs, fields
func (_m *UniversalClient) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireAtWithArgs")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, redis.HExpireArgs, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HExpireTime provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireTime")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HExpireWithArgs provides a mock function with given fields: ctx, key, expiration, expirationArgs, fields
func (_m *UniversalClient) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireWithArgs")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, redis.HExpireArgs, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HGet provides a mock function with given fields: ctx, key, field
func (_m *UniversalClient) HGet(ctx context.Context, key string, field string) *redis.StringCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HGetAll provides a mock function with given fields: ctx, key
func (_m *UniversalClient) HGetAll(ctx context.Context, key string) *redis.MapStringStringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 *redis.MapStringStringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.MapStringStringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringStringCmd)
		}
	}

	return r0
}

// HGetDel provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HGetDel(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HGetDel")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HGetEX provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HGetEX(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HGetEX")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HGetEXWithArgs provides a mock function with given fields: ctx, key, options, fields
func (_m *UniversalClient) HGetEXWithArgs(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HGetEXWithArgs")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.HGetEXOptions, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, options, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HIncrBy provides a mock function with given fields: ctx, key, field, incr
func (_m *UniversalClient) HIncrBy(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HIncrByFloat provides a mock function with given fields: ctx, key, field, incr
func (_m *UniversalClient) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// HKeys provides a mock function with given fields: ctx, key
func (_m *UniversalClient) HKeys(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HKeys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HLen provides a mock function with given fields: ctx, key
func (_m *UniversalClient) HLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HMGet provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HMGet(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// HMSet provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) HMSet(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HPExpire provides a mock function with given fields: ctx, key, expiration, fields
func (_m *UniversalClient) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpire")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HPExpireAt provides a mock function with given fields: ctx, key, tm, fields
func (_m *UniversalClient) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireAt")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HPExpireAtWithArgs provides a mock function with given fields: ctx, key, tm, expirationArgs, fields
func (_m *UniversalClient) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireAtWithArgs")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, redis.HExpireArgs, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HPExpireTime provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HPExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireTime")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HPExpireWithArgs provides a mock function with given fields: ctx, key, expiration, expirationArgs, fields
func (_m *UniversalClient) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireWithArgs")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, redis.HExpireArgs, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HPTTL provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HPTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPTTL")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HPersist provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HPersist(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPersist")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HRandField provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) HRandField(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for HRandField")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HRandFieldWithValues provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) HRandFieldWithValues(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for HRandFieldWithValues")
	}

	var r0 *redis.KeyValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.KeyValueSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.KeyValueSliceCmd)
		}
	}

	return r0
}

// HScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *UniversalClient) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// HScanNoValues provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *UniversalClient) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScanNoValues")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// HSet provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) HSet(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HSetEX provides a mock function with given fields: ctx, key, fieldsAndValues
func (_m *UniversalClient) HSetEX(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fieldsAndValues))
	for _i := range fieldsAndValues {
		_va[_i] = fieldsAndValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSetEX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, fieldsAndValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HSetEXWithArgs provides a mock function with given fields: ctx, key, options, fieldsAndValues
func (_m *UniversalClient) HSetEXWithArgs(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fieldsAndValues))
	for _i := range fieldsAndValues {
		_va[_i] = fieldsAndValues[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSetEXWithArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.HSetEXOptions, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, options, fieldsAndValues...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HSetNX provides a mock function with given fields: ctx, key, field, value
func (_m *UniversalClient) HSetNX(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HStrLen provides a mock function with given fields: ctx, key, field
func (_m *UniversalClient) HStrLen(ctx context.Context, key string, field string) *redis.IntCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HStrLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HTTL provides a mock function with given fields: ctx, key, fields
func (_m *UniversalClient) HTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTL")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// HVals provides a mock function with given fields: ctx, key
func (_m *UniversalClient) HVals(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HVals")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// Incr provides a mock function with given fields: ctx, key
func (_m *UniversalClient) Incr(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Incr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrBy provides a mock function with given fields: ctx, key, value
func (_m *UniversalClient) IncrBy(ctx context.Context, key string, value int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrByFloat provides a mock function with given fields: ctx, key, value
func (_m *UniversalClient) IncrByFloat(ctx context.Context, key string, value float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// Info provides a mock function with given fields: ctx, section
func (_m *UniversalClient) Info(ctx context.Context, section ...string) *redis.StringCmd {
	_va := make([]interface{}, len(section))
	for _i := range section {
		_va[_i] = section[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringCmd); ok {
		r0 = rf(ctx, section...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// JSONArrAppend provides a mock function with given fields: ctx, key, path, values
func (_m *UniversalClient) JSONArrAppend(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrAppend")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONArrIndex provides a mock function with given fields: ctx, key, path, value
func (_m *UniversalClient) JSONArrIndex(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrIndex")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path, value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONArrIndexWithArgs provides a mock function with given fields: ctx, key, path, options, value
func (_m *UniversalClient) JSONArrIndexWithArgs(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path, options)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrIndexWithArgs")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.JSONArrIndexArgs, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path, options, value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONArrInsert provides a mock function with given fields: ctx, key, path, index, values
func (_m *UniversalClient) JSONArrInsert(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path, index)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrInsert")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path, index, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONArrLen provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONArrLen(ctx context.Context, key string, path string) *redis.IntSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrLen")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONArrPop provides a mock function with given fields: ctx, key, path, index
func (_m *UniversalClient) JSONArrPop(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, path, index)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, path, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// JSONArrTrim provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONArrTrim(ctx context.Context, key string, path string) *redis.IntSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrTrim")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONArrTrimWithArgs provides a mock function with given fields: ctx, key, path, options
func (_m *UniversalClient) JSONArrTrimWithArgs(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd {
	ret := _m.Called(ctx, key, path, options)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrTrimWithArgs")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.JSONArrTrimArgs) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, path, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// JSONClear provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONClear(ctx context.Context, key string, path string) *redis.IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONClear")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// JSONDebugMemory provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONDebugMemory(ctx context.Context, key string, path string) *redis.IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONDebugMemory")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// JSONDel provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONDel(ctx context.Context, key string, path string) *redis.IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// JSONForget provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONForget(ctx context.Context, key string, path string) *redis.IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONForget")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// JSONGet provides a mock function with given fields: ctx, key, paths
func (_m *UniversalClient) JSONGet(ctx context.Context, key string, paths ...string) *redis.JSONCmd {
	_va := make([]interface{}, len(paths))
	for _i := range paths {
		_va[_i] = paths[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONGet")
	}

	var r0 *redis.JSONCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.JSONCmd); ok {
		r0 = rf(ctx, key, paths...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.JSONCmd)
		}
	}

	return r0
}

// JSONGetWithArgs provides a mock function with given fields: ctx, key, options, paths
func (_m *UniversalClient) JSONGetWithArgs(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd {
	_va := make([]interface{}, len(paths))
	for _i := range paths {
		_va[_i] = paths[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONGetWithArgs")
	}

	var r0 *redis.JSONCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.JSONGetArgs, ...string) *redis.JSONCmd); ok {
		r0 = rf(ctx, key, options, paths...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.JSONCmd)
		}
	}

	return r0
}

// JSONMGet provides a mock function with given fields: ctx, path, keys
func (_m *UniversalClient) JSONMGet(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, path)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONMGet")
	}

	var r0 *redis.JSONSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.JSONSliceCmd); ok {
		r0 = rf(ctx, path, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.JSONSliceCmd)
		}
	}

	return r0
}

// JSONMSet provides a mock function with given fields: ctx, params
func (_m *UniversalClient) JSONMSet(ctx context.Context, params ...interface{}) *redis.StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONMSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, params...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// JSONMSetArgs provides a mock function with given fields: ctx, docs
func (_m *UniversalClient) JSONMSetArgs(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd {
	ret := _m.Called(ctx, docs)

	if len(ret) == 0 {
		panic("no return value specified for JSONMSetArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, []redis.JSONSetArgs) *redis.StatusCmd); ok {
		r0 = rf(ctx, docs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// JSONMerge provides a mock function with given fields: ctx, key, path, value
func (_m *UniversalClient) JSONMerge(ctx context.Context, key string, path string, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// JSONNumIncrBy provides a mock function with given fields: ctx, key, path, value
func (_m *UniversalClient) JSONNumIncrBy(ctx context.Context, key string, path string, value float64) *redis.JSONCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONNumIncrBy")
	}

	var r0 *redis.JSONCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *redis.JSONCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.JSONCmd)
		}
	}

	return r0
}

// JSONObjKeys provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONObjKeys(ctx context.Context, key string, path string) *redis.SliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONObjKeys")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// JSONObjLen provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONObjLen(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONObjLen")
	}

	var r0 *redis.IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntPointerSliceCmd)
		}
	}

	return r0
}

// JSONSet provides a mock function with given fields: ctx, key, path, value
func (_m *UniversalClient) JSONSet(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// JSONSetMode provides a mock function with given fields: ctx, key, path, value, mode
func (_m *UniversalClient) JSONSetMode(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, path, value, mode)

	if len(ret) == 0 {
		panic("no return value specified for JSONSetMode")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, path, value, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// JSONStrAppend provides a mock function with given fields: ctx, key, path, value
func (_m *UniversalClient) JSONStrAppend(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONStrAppend")
	}

	var r0 *redis.IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntPointerSliceCmd)
		}
	}

	return r0
}

// JSONStrLen provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONStrLen(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONStrLen")
	}

	var r0 *redis.IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntPointerSliceCmd)
		}
	}

	return r0
}

// JSONToggle provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONToggle(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONToggle")
	}

	var r0 *redis.IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntPointerSliceCmd)
		}
	}

	return r0
}

// JSONType provides a mock function with given fields: ctx, key, path
func (_m *UniversalClient) JSONType(ctx context.Context, key string, path string) *redis.JSONSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONType")
	}

	var r0 *redis.JSONSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.JSONSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.JSONSliceCmd)
		}
	}

	return r0
}

// Keys provides a mock function with given fields: ctx, pattern
func (_m *UniversalClient) Keys(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LCS provides a mock function with given fields: ctx, q
func (_m *UniversalClient) LCS(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for LCS")
	}

	var r0 *redis.LCSCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.LCSQuery) *redis.LCSCmd); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.LCSCmd)
		}
	}

	return r0
}

// LIndex provides a mock function with given fields: ctx, key, index
func (_m *UniversalClient) LIndex(ctx context.Context, key string, index int64) *redis.StringCmd {
	ret := _m.Called(ctx, key, index)

	if len(ret) == 0 {
		panic("no return value specified for LIndex")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringCmd); ok {
		r0 = rf(ctx, key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LInsert provides a mock function with given fields: ctx, key, op, pivot, value
func (_m *UniversalClient) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, op, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsert")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertAfter provides a mock function with given fields: ctx, key, pivot, value
func (_m *UniversalClient) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertAfter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertBefore provides a mock function with given fields: ctx, key, pivot, value
func (_m *UniversalClient) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertBefore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LLen provides a mock function with given fields: ctx, key
func (_m *UniversalClient) LLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LMPop provides a mock function with given fields: ctx, direction, count, keys
func (_m *UniversalClient) LMPop(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, direction, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LMPop")
	}

	var r0 *redis.KeyValuesCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...string) *redis.KeyValuesCmd); ok {
		r0 = rf(ctx, direction, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.KeyValuesCmd)
		}
	}

	return r0
}

// LMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos
func (_m *UniversalClient) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos)

	if len(ret) == 0 {
		panic("no return value specified for LMove")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LPop provides a mock function with given fields: ctx, key
func (_m *UniversalClient) LPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LPopCount provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) LPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for LPopCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LPos provides a mock function with given fields: ctx, key, value, args
func (_m *UniversalClient) LPos(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
	ret := _m.Called(ctx, key, value, args)

	if len(ret) == 0 {
		panic("no return value specified for LPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.LPosArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPosCount provides a mock function with given fields: ctx, key, value, count, args
func (_m *UniversalClient) LPosCount(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
	ret := _m.Called(ctx, key, value, count, args)

	if len(ret) == 0 {
		panic("no return value specified for LPosCount")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, redis.LPosArgs) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, value, count, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// LPush provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) LPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPushX provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) LPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LRange provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) LRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LRem provides a mock function with given fields: ctx, key, count, value
func (_m *UniversalClient) LRem(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, count, value)

	if len(ret) == 0 {
		panic("no return value specified for LRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LSet provides a mock function with given fields: ctx, key, index, value
func (_m *UniversalClient) LSet(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, key, index, value)

	if len(ret) == 0 {
		panic("no return value specified for LSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LTrim provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) LTrim(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LTrim")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LastSave provides a mock function with given fields: ctx
func (_m *UniversalClient) LastSave(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LastSave")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MGet provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) MGet(ctx context.Context, keys ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.SliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MSet provides a mock function with given fields: ctx, values
func (_m *UniversalClient) MSet(ctx context.Context, values ...interface{}) *redis.StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MSetNX provides a mock function with given fields: ctx, values
func (_m *UniversalClient) MSetNX(ctx context.Context, values ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MemoryUsage provides a mock function with given fields: ctx, key, samples
func (_m *UniversalClient) MemoryUsage(ctx context.Context, key string, samples ...int) *redis.IntCmd {
	_va := make([]interface{}, len(samples))
	for _i := range samples {
		_va[_i] = samples[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsage")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int) *redis.IntCmd); ok {
		r0 = rf(ctx, key, samples...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Migrate provides a mock function with given fields: ctx, host, port, key, db, timeout
func (_m *UniversalClient) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port, key, db, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ModuleLoadex provides a mock function with given fields: ctx, conf
func (_m *UniversalClient) ModuleLoadex(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd {
	ret := _m.Called(ctx, conf)

	if len(ret) == 0 {
		panic("no return value specified for ModuleLoadex")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ModuleLoadexConfig) *redis.StringCmd); ok {
		r0 = rf(ctx, conf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Move provides a mock function with given fields: ctx, key, db
func (_m *UniversalClient) Move(ctx context.Context, key string, db int) *redis.BoolCmd {
	ret := _m.Called(ctx, key, db)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ObjectEncoding provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ObjectEncoding(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectEncoding")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ObjectFreq provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ObjectFreq(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectFreq")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ObjectIdleTime provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ObjectIdleTime(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectIdleTime")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// ObjectRefCount provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ObjectRefCount(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectRefCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PExpire provides a mock function with given fields: ctx, key, expiration
func (_m *UniversalClient) PExpire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for PExpire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *UniversalClient) PExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for PExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PExpireTime provides a mock function with given fields: ctx, key
func (_m *UniversalClient) PExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PExpireTime")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// PFAdd provides a mock function with given fields: ctx, key, els
func (_m *UniversalClient) PFAdd(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, els...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, els...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFCount provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) PFCount(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFMerge provides a mock function with given fields: ctx, dest, keys
func (_m *UniversalClient) PFMerge(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StatusCmd); ok {
		r0 = rf(ctx, dest, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// PSubscribe provides a mock function with given fields: ctx, channels
func (_m *UniversalClient) PSubscribe(ctx context.Context, channels ...string) *redis.PubSub {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PSubscribe")
	}

	var r0 *redis.PubSub
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.PubSub); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PubSub)
		}
	}

	return r0
}

// PTTL provides a mock function with given fields: ctx, key
func (_m *UniversalClient) PTTL(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PTTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Persist provides a mock function with given fields: ctx, key
func (_m *UniversalClient) Persist(ctx context.Context, key string) *redis.BoolCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Persist")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Ping provides a mock function with given fields: ctx
func (_m *UniversalClient) Ping(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Pipeline provides a mock function with no fields
func (_m *UniversalClient) Pipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Pipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// Pipelined provides a mock function with given fields: ctx, fn
func (_m *UniversalClient) Pipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Pipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(redis.Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PoolStats provides a mock function with no fields
func (_m *UniversalClient) PoolStats() *redis.PoolStats {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PoolStats")
	}

	var r0 *redis.PoolStats
	if rf, ok := ret.Get(0).(func() *redis.PoolStats); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PoolStats)
		}
	}

	return r0
}

// Process provides a mock function with given fields: ctx, cmd
func (_m *UniversalClient) Process(ctx context.Context, cmd redis.Cmder) error {
	ret := _m.Called(ctx, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, redis.Cmder) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PubSubChannels provides a mock function with given fields: ctx, pattern
func (_m *UniversalClient) PubSubChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubChannels")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// PubSubNumPat provides a mock function with given fields: ctx
func (_m *UniversalClient) PubSubNumPat(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumPat")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PubSubNumSub provides a mock function with given fields: ctx, channels
func (_m *UniversalClient) PubSubNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumSub")
	}

	var r0 *redis.MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.MapStringIntCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringIntCmd)
		}
	}

	return r0
}

// PubSubShardChannels provides a mock function with given fields: ctx, pattern
func (_m *UniversalClient) PubSubShardChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubShardChannels")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// PubSubShardNumSub provides a mock function with given fields: ctx, channels
func (_m *UniversalClient) PubSubShardNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubShardNumSub")
	}

	var r0 *redis.MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.MapStringIntCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringIntCmd)
		}
	}

	return r0
}

// Publish provides a mock function with given fields: ctx, channel, message
func (_m *UniversalClient) Publish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Quit provides a mock function with given fields: ctx
func (_m *UniversalClient) Quit(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Quit")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RPop provides a mock function with given fields: ctx, key
func (_m *UniversalClient) RPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for RPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPopCount provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) RPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for RPopCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// RPopLPush provides a mock function with given fields: ctx, source, destination
func (_m *UniversalClient) RPopLPush(ctx context.Context, source string, destination string) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination)

	if len(ret) == 0 {
		panic("no return value specified for RPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPush provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) RPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RPushX provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) RPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RandomKey provides a mock function with given fields: ctx
func (_m *UniversalClient) RandomKey(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RandomKey")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ReadOnly provides a mock function with given fields: ctx
func (_m *UniversalClient) ReadOnly(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnly")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ReadWrite provides a mock function with given fields: ctx
func (_m *UniversalClient) ReadWrite(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadWrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Rename provides a mock function with given fields: ctx, key, newkey
func (_m *UniversalClient) Rename(ctx context.Context, key string, newkey string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RenameNX provides a mock function with given fields: ctx, key, newkey
func (_m *UniversalClient) RenameNX(ctx context.Context, key string, newkey string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for RenameNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Restore provides a mock function with given fields: ctx, key, ttl, value
func (_m *UniversalClient) Restore(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RestoreReplace provides a mock function with given fields: ctx, key, ttl, value
func (_m *UniversalClient) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for RestoreReplace")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SAdd provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) SAdd(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SCard provides a mock function with given fields: ctx, key
func (_m *UniversalClient) SCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SDiff provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) SDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *UniversalClient) SDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SInter provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) SInter(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SInterCard provides a mock function with given fields: ctx, limit, keys
func (_m *UniversalClient) SInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, limit, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SInterStore provides a mock function with given fields: ctx, destination, keys
func (_m *UniversalClient) SInterStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SIsMember provides a mock function with given fields: ctx, key, member
func (_m *UniversalClient) SIsMember(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for SIsMember")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SMIsMember provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) SMIsMember(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SMIsMember")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// SMembers provides a mock function with given fields: ctx, key
func (_m *UniversalClient) SMembers(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembers")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SMembersMap provides a mock function with given fields: ctx, key
func (_m *UniversalClient) SMembersMap(ctx context.Context, key string) *redis.StringStructMapCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembersMap")
	}

	var r0 *redis.StringStructMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringStructMapCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStructMapCmd)
		}
	}

	return r0
}

// SMove provides a mock function with given fields: ctx, source, destination, member
func (_m *UniversalClient) SMove(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, source, destination, member)

	if len(ret) == 0 {
		panic("no return value specified for SMove")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, source, destination, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SPop provides a mock function with given fields: ctx, key
func (_m *UniversalClient) SPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SPopN provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) SPopN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SPopN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SPublish provides a mock function with given fields: ctx, channel, message
func (_m *UniversalClient) SPublish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for SPublish")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SRandMember provides a mock function with given fields: ctx, key
func (_m *UniversalClient) SRandMember(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SRandMember")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SRandMemberN provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) SRandMemberN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SRandMemberN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRem provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) SRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *UniversalClient) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for SScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// SSubscribe provides a mock function with given fields: ctx, channels
func (_m *UniversalClient) SSubscribe(ctx context.Context, channels ...string) *redis.PubSub {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SSubscribe")
	}

	var r0 *redis.PubSub
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.PubSub); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PubSub)
		}
	}

	return r0
}

// SUnion provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) SUnion(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SUnionStore provides a mock function with given fields: ctx, destination, keys
func (_m *UniversalClient) SUnionStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Save provides a mock function with given fields: ctx
func (_m *UniversalClient) Save(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Scan provides a mock function with given fields: ctx, cursor, match, count
func (_m *UniversalClient) Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ScanType provides a mock function with given fields: ctx, cursor, match, count, keyType
func (_m *UniversalClient) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
	ret := _m.Called(ctx, cursor, match, count, keyType)

	if len(ret) == 0 {
		panic("no return value specified for ScanType")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64, string) *redis.ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count, keyType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ScriptExists provides a mock function with given fields: ctx, hashes
func (_m *UniversalClient) ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScriptExists")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// ScriptFlush provides a mock function with given fields: ctx
func (_m *UniversalClient) ScriptFlush(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptFlush")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptKill provides a mock function with given fields: ctx
func (_m *UniversalClient) ScriptKill(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptLoad provides a mock function with given fields: ctx, script
func (_m *UniversalClient) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	ret := _m.Called(ctx, script)

	if len(ret) == 0 {
		panic("no return value specified for ScriptLoad")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Set provides a mock function with given fields: ctx, key, value, expiration
func (_m *UniversalClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetArgs provides a mock function with given fields: ctx, key, value, a
func (_m *UniversalClient) SetArgs(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, a)

	if len(ret) == 0 {
		panic("no return value specified for SetArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, redis.SetArgs) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *UniversalClient) SetBit(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetEx provides a mock function with given fields: ctx, key, value, expiration
func (_m *UniversalClient) SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetEx")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetNX provides a mock function with given fields: ctx, key, value, expiration
func (_m *UniversalClient) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SetRange provides a mock function with given fields: ctx, key, offset, value
func (_m *UniversalClient) SetRange(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetRange")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetXX provides a mock function with given fields: ctx, key, value, expiration
func (_m *UniversalClient) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Shutdown provides a mock function with given fields: ctx
func (_m *UniversalClient) Shutdown(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownNoSave provides a mock function with given fields: ctx
func (_m *UniversalClient) ShutdownNoSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownNoSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownSave provides a mock function with given fields: ctx
func (_m *UniversalClient) ShutdownSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SlaveOf provides a mock function with given fields: ctx, host, port
func (_m *UniversalClient) SlaveOf(ctx context.Context, host string, port string) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for SlaveOf")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SlowLogGet provides a mock function with given fields: ctx, num
func (_m *UniversalClient) SlowLogGet(ctx context.Context, num int64) *redis.SlowLogCmd {
	ret := _m.Called(ctx, num)

	if len(ret) == 0 {
		panic("no return value specified for SlowLogGet")
	}

	var r0 *redis.SlowLogCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *redis.SlowLogCmd); ok {
		r0 = rf(ctx, num)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SlowLogCmd)
		}
	}

	return r0
}

// Sort provides a mock function with given fields: ctx, key, sort
func (_m *UniversalClient) Sort(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for Sort")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SortInterfaces provides a mock function with given fields: ctx, key, sort
func (_m *UniversalClient) SortInterfaces(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortInterfaces")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// SortRO provides a mock function with given fields: ctx, key, sort
func (_m *UniversalClient) SortRO(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortRO")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SortStore provides a mock function with given fields: ctx, key, store, sort
func (_m *UniversalClient) SortStore(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
	ret := _m.Called(ctx, key, store, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.Sort) *redis.IntCmd); ok {
		r0 = rf(ctx, key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// StrLen provides a mock function with given fields: ctx, key
func (_m *UniversalClient) StrLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for StrLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Subscribe provides a mock function with given fields: ctx, channels
func (_m *UniversalClient) Subscribe(ctx context.Context, channels ...string) *redis.PubSub {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 *redis.PubSub
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.PubSub); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PubSub)
		}
	}

	return r0
}

// TDigestAdd provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TDigestAdd(ctx context.Context, key string, elements ...float64) *redis.StatusCmd {
	_va := make([]interface{}, len(elements))
	for _i := range elements {
		_va[_i] = elements[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestAdd")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TDigestByRank provides a mock function with given fields: ctx, key, rank
func (_m *UniversalClient) TDigestByRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(rank))
	for _i := range rank {
		_va[_i] = rank[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestByRank")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...uint64) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, rank...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// TDigestByRevRank provides a mock function with given fields: ctx, key, rank
func (_m *UniversalClient) TDigestByRevRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(rank))
	for _i := range rank {
		_va[_i] = rank[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestByRevRank")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...uint64) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, rank...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// TDigestCDF provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TDigestCDF(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(elements))
	for _i := range elements {
		_va[_i] = elements[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestCDF")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// TDigestCreate provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TDigestCreate(ctx context.Context, key string) *redis.StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TDigestCreateWithCompression provides a mock function with given fields: ctx, key, compression
func (_m *UniversalClient) TDigestCreateWithCompression(ctx context.Context, key string, compression int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, compression)

	if len(ret) == 0 {
		panic("no return value specified for TDigestCreateWithCompression")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, compression)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TDigestInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TDigestInfo(ctx context.Context, key string) *redis.TDigestInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestInfo")
	}

	var r0 *redis.TDigestInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.TDigestInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TDigestInfoCmd)
		}
	}

	return r0
}

// TDigestMax provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TDigestMax(ctx context.Context, key string) *redis.FloatCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestMax")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// TDigestMerge provides a mock function with given fields: ctx, destKey, options, sourceKeys
func (_m *UniversalClient) TDigestMerge(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(sourceKeys))
	for _i := range sourceKeys {
		_va[_i] = sourceKeys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.TDigestMergeOptions, ...string) *redis.StatusCmd); ok {
		r0 = rf(ctx, destKey, options, sourceKeys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TDigestMin provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TDigestMin(ctx context.Context, key string) *redis.FloatCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestMin")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// TDigestQuantile provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TDigestQuantile(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(elements))
	for _i := range elements {
		_va[_i] = elements[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestQuantile")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// TDigestRank provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) TDigestRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestRank")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// TDigestReset provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TDigestReset(ctx context.Context, key string) *redis.StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestReset")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TDigestRevRank provides a mock function with given fields: ctx, key, values
func (_m *UniversalClient) TDigestRevRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestRevRank")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// TDigestTrimmedMean provides a mock function with given fields: ctx, key, lowCutQuantile, highCutQuantile
func (_m *UniversalClient) TDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, lowCutQuantile, highCutQuantile)

	if len(ret) == 0 {
		panic("no return value specified for TDigestTrimmedMean")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, lowCutQuantile, highCutQuantile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// TSAdd provides a mock function with given fields: ctx, key, timestamp, value
func (_m *UniversalClient) TSAdd(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd {
	ret := _m.Called(ctx, key, timestamp, value)

	if len(ret) == 0 {
		panic("no return value specified for TSAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, float64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, timestamp, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSAddWithArgs provides a mock function with given fields: ctx, key, timestamp, value, options
func (_m *UniversalClient) TSAddWithArgs(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd {
	ret := _m.Called(ctx, key, timestamp, value, options)

	if len(ret) == 0 {
		panic("no return value specified for TSAddWithArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, float64, *redis.TSOptions) *redis.IntCmd); ok {
		r0 = rf(ctx, key, timestamp, value, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSAlter provides a mock function with given fields: ctx, key, options
func (_m *UniversalClient) TSAlter(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSAlter")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.TSAlterOptions) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TSCreate provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TSCreate(ctx context.Context, key string) *redis.StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TSCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TSCreateRule provides a mock function with given fields: ctx, sourceKey, destKey, aggregator, bucketDuration
func (_m *UniversalClient) TSCreateRule(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd {
	ret := _m.Called(ctx, sourceKey, destKey, aggregator, bucketDuration)

	if len(ret) == 0 {
		panic("no return value specified for TSCreateRule")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.Aggregator, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, aggregator, bucketDuration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TSCreateRuleWithArgs provides a mock function with given fields: ctx, sourceKey, destKey, aggregator, bucketDuration, options
func (_m *UniversalClient) TSCreateRuleWithArgs(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd {
	ret := _m.Called(ctx, sourceKey, destKey, aggregator, bucketDuration, options)

	if len(ret) == 0 {
		panic("no return value specified for TSCreateRuleWithArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.Aggregator, int, *redis.TSCreateRuleOptions) *redis.StatusCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, aggregator, bucketDuration, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TSCreateWithArgs provides a mock function with given fields: ctx, key, options
func (_m *UniversalClient) TSCreateWithArgs(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSCreateWithArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.TSOptions) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TSDecrBy provides a mock function with given fields: ctx, Key, timestamp
func (_m *UniversalClient) TSDecrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	ret := _m.Called(ctx, Key, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSDecrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *redis.IntCmd); ok {
		r0 = rf(ctx, Key, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSDecrByWithArgs provides a mock function with given fields: ctx, key, timestamp, options
func (_m *UniversalClient) TSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	ret := _m.Called(ctx, key, timestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSDecrByWithArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, *redis.TSIncrDecrOptions) *redis.IntCmd); ok {
		r0 = rf(ctx, key, timestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSDel provides a mock function with given fields: ctx, Key, fromTimestamp, toTimestamp
func (_m *UniversalClient) TSDel(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd {
	ret := _m.Called(ctx, Key, fromTimestamp, toTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *redis.IntCmd); ok {
		r0 = rf(ctx, Key, fromTimestamp, toTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSDeleteRule provides a mock function with given fields: ctx, sourceKey, destKey
func (_m *UniversalClient) TSDeleteRule(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd {
	ret := _m.Called(ctx, sourceKey, destKey)

	if len(ret) == 0 {
		panic("no return value specified for TSDeleteRule")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, sourceKey, destKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TSGet provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TSGet(ctx context.Context, key string) *redis.TSTimestampValueCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TSGet")
	}

	var r0 *redis.TSTimestampValueCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.TSTimestampValueCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TSTimestampValueCmd)
		}
	}

	return r0
}

// TSGetWithArgs provides a mock function with given fields: ctx, key, options
func (_m *UniversalClient) TSGetWithArgs(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSGetWithArgs")
	}

	var r0 *redis.TSTimestampValueCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.TSGetOptions) *redis.TSTimestampValueCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TSTimestampValueCmd)
		}
	}

	return r0
}

// TSIncrBy provides a mock function with given fields: ctx, Key, timestamp
func (_m *UniversalClient) TSIncrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	ret := _m.Called(ctx, Key, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSIncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *redis.IntCmd); ok {
		r0 = rf(ctx, Key, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSIncrByWithArgs provides a mock function with given fields: ctx, key, timestamp, options
func (_m *UniversalClient) TSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	ret := _m.Called(ctx, key, timestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSIncrByWithArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, *redis.TSIncrDecrOptions) *redis.IntCmd); ok {
		r0 = rf(ctx, key, timestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TSInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TSInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TSInfo")
	}

	var r0 *redis.MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.MapStringInterfaceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringInterfaceCmd)
		}
	}

	return r0
}

// TSInfoWithArgs provides a mock function with given fields: ctx, key, options
func (_m *UniversalClient) TSInfoWithArgs(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSInfoWithArgs")
	}

	var r0 *redis.MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.TSInfoOptions) *redis.MapStringInterfaceCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringInterfaceCmd)
		}
	}

	return r0
}

// TSMAdd provides a mock function with given fields: ctx, ktvSlices
func (_m *UniversalClient) TSMAdd(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd {
	ret := _m.Called(ctx, ktvSlices)

	if len(ret) == 0 {
		panic("no return value specified for TSMAdd")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, [][]interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, ktvSlices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// TSMGet provides a mock function with given fields: ctx, filters
func (_m *UniversalClient) TSMGet(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for TSMGet")
	}

	var r0 *redis.MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, []string) *redis.MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// TSMGetWithArgs provides a mock function with given fields: ctx, filters, options
func (_m *UniversalClient) TSMGetWithArgs(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, filters, options)

	if len(ret) == 0 {
		panic("no return value specified for TSMGetWithArgs")
	}

	var r0 *redis.MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, []string, *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, filters, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// TSMRange provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr
func (_m *UniversalClient) TSMRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr)

	if len(ret) == 0 {
		panic("no return value specified for TSMRange")
	}

	var r0 *redis.MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string) *redis.MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// TSMRangeWithArgs provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr, options
func (_m *UniversalClient) TSMRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr, options)

	if len(ret) == 0 {
		panic("no return value specified for TSMRangeWithArgs")
	}

	var r0 *redis.MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string, *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// TSMRevRange provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr
func (_m *UniversalClient) TSMRevRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr)

	if len(ret) == 0 {
		panic("no return value specified for TSMRevRange")
	}

	var r0 *redis.MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string) *redis.MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// TSMRevRangeWithArgs provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr, options
func (_m *UniversalClient) TSMRevRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr, options)

	if len(ret) == 0 {
		panic("no return value specified for TSMRevRangeWithArgs")
	}

	var r0 *redis.MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string, *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// TSQueryIndex provides a mock function with given fields: ctx, filterExpr
func (_m *UniversalClient) TSQueryIndex(ctx context.Context, filterExpr []string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, filterExpr)

	if len(ret) == 0 {
		panic("no return value specified for TSQueryIndex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, []string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, filterExpr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// TSRange provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp
func (_m *UniversalClient) TSRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSRange")
	}

	var r0 *redis.TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *redis.TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// TSRangeWithArgs provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp, options
func (_m *UniversalClient) TSRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSRangeWithArgs")
	}

	var r0 *redis.TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// TSRevRange provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp
func (_m *UniversalClient) TSRevRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSRevRange")
	}

	var r0 *redis.TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *redis.TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// TSRevRangeWithArgs provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp, options
func (_m *UniversalClient) TSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSRevRangeWithArgs")
	}

	var r0 *redis.TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// TTL provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TTL(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Time provides a mock function with given fields: ctx
func (_m *UniversalClient) Time(ctx context.Context) *redis.TimeCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 *redis.TimeCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.TimeCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TimeCmd)
		}
	}

	return r0
}

// TopKAdd provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TopKAdd(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKAdd")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// TopKCount provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TopKCount(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKCount")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// TopKIncrBy provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TopKIncrBy(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKIncrBy")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// TopKInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TopKInfo(ctx context.Context, key string) *redis.TopKInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TopKInfo")
	}

	var r0 *redis.TopKInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.TopKInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TopKInfoCmd)
		}
	}

	return r0
}

// TopKList provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TopKList(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TopKList")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// TopKListWithCount provides a mock function with given fields: ctx, key
func (_m *UniversalClient) TopKListWithCount(ctx context.Context, key string) *redis.MapStringIntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TopKListWithCount")
	}

	var r0 *redis.MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.MapStringIntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringIntCmd)
		}
	}

	return r0
}

// TopKQuery provides a mock function with given fields: ctx, key, elements
func (_m *UniversalClient) TopKQuery(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKQuery")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// TopKReserve provides a mock function with given fields: ctx, key, k
func (_m *UniversalClient) TopKReserve(ctx context.Context, key string, k int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, k)

	if len(ret) == 0 {
		panic("no return value specified for TopKReserve")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, k)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// TopKReserveWithOptions provides a mock function with given fields: ctx, key, k, width, depth, decay
func (_m *UniversalClient) TopKReserveWithOptions(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, k, width, depth, decay)

	if len(ret) == 0 {
		panic("no return value specified for TopKReserveWithOptions")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64, int64, float64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, k, width, depth, decay)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Touch provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) Touch(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Touch")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TxPipeline provides a mock function with no fields
func (_m *UniversalClient) TxPipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxPipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// TxPipelined provides a mock function with given fields: ctx, fn
func (_m *UniversalClient) TxPipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for TxPipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(redis.Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields: ctx, key
func (_m *UniversalClient) Type(ctx context.Context, key string) *redis.StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Unlink provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) Unlink(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Unlink")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// VAdd provides a mock function with given fields: ctx, key, element, val
func (_m *UniversalClient) VAdd(ctx context.Context, key string, element string, val redis.Vector) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element, val)

	if len(ret) == 0 {
		panic("no return value specified for VAdd")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.Vector) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element, val)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// VAddWithArgs provides a mock function with given fields: ctx, key, element, val, addArgs
func (_m *UniversalClient) VAddWithArgs(ctx context.Context, key string, element string, val redis.Vector, addArgs *redis.VAddArgs) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element, val, addArgs)

	if len(ret) == 0 {
		panic("no return value specified for VAddWithArgs")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.Vector, *redis.VAddArgs) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element, val, addArgs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// VCard provides a mock function with given fields: ctx, key
func (_m *UniversalClient) VCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for VCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// VClearAttributes provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) VClearAttributes(ctx context.Context, key string, element string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for VClearAttributes")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// VDim provides a mock function with given fields: ctx, key
func (_m *UniversalClient) VDim(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for VDim")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// VEmb provides a mock function with given fields: ctx, key, element, raw
func (_m *UniversalClient) VEmb(ctx context.Context, key string, element string, raw bool) *redis.SliceCmd {
	ret := _m.Called(ctx, key, element, raw)

	if len(ret) == 0 {
		panic("no return value specified for VEmb")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, element, raw)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// VGetAttr provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) VGetAttr(ctx context.Context, key string, element string) *redis.StringCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for VGetAttr")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// VInfo provides a mock function with given fields: ctx, key
func (_m *UniversalClient) VInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for VInfo")
	}

	var r0 *redis.MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.MapStringInterfaceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.MapStringInterfaceCmd)
		}
	}

	return r0
}

// VLinks provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) VLinks(ctx context.Context, key string, element string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for VLinks")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// VLinksWithScores provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) VLinksWithScores(ctx context.Context, key string, element string) *redis.VectorScoreSliceCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for VLinksWithScores")
	}

	var r0 *redis.VectorScoreSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.VectorScoreSliceCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.VectorScoreSliceCmd)
		}
	}

	return r0
}

// VRandMember provides a mock function with given fields: ctx, key
func (_m *UniversalClient) VRandMember(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for VRandMember")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// VRandMemberCount provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) VRandMemberCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for VRandMemberCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// VRem provides a mock function with given fields: ctx, key, element
func (_m *UniversalClient) VRem(ctx context.Context, key string, element string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for VRem")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// VSetAttr provides a mock function with given fields: ctx, key, element, attr
func (_m *UniversalClient) VSetAttr(ctx context.Context, key string, element string, attr interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, element, attr)

	if len(ret) == 0 {
		panic("no return value specified for VSetAttr")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, element, attr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// VSim provides a mock function with given fields: ctx, key, val
func (_m *UniversalClient) VSim(ctx context.Context, key string, val redis.Vector) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, val)

	if len(ret) == 0 {
		panic("no return value specified for VSim")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.Vector) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, val)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// VSimWithArgs provides a mock function with given fields: ctx, key, val, args
func (_m *UniversalClient) VSimWithArgs(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, val, args)

	if len(ret) == 0 {
		panic("no return value specified for VSimWithArgs")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.Vector, *redis.VSimArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, val, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// VSimWithArgsWithScores provides a mock function with given fields: ctx, key, val, args
func (_m *UniversalClient) VSimWithArgsWithScores(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.VectorScoreSliceCmd {
	ret := _m.Called(ctx, key, val, args)

	if len(ret) == 0 {
		panic("no return value specified for VSimWithArgsWithScores")
	}

	var r0 *redis.VectorScoreSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.Vector, *redis.VSimArgs) *redis.VectorScoreSliceCmd); ok {
		r0 = rf(ctx, key, val, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.VectorScoreSliceCmd)
		}
	}

	return r0
}

// VSimWithScores provides a mock function with given fields: ctx, key, val
func (_m *UniversalClient) VSimWithScores(ctx context.Context, key string, val redis.Vector) *redis.VectorScoreSliceCmd {
	ret := _m.Called(ctx, key, val)

	if len(ret) == 0 {
		panic("no return value specified for VSimWithScores")
	}

	var r0 *redis.VectorScoreSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.Vector) *redis.VectorScoreSliceCmd); ok {
		r0 = rf(ctx, key, val)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.VectorScoreSliceCmd)
		}
	}

	return r0
}

// Watch provides a mock function with given fields: ctx, fn, keys
func (_m *UniversalClient) Watch(ctx context.Context, fn func(*redis.Tx) error, keys ...string) error {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, fn)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Watch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(*redis.Tx) error, ...string) error); ok {
		r0 = rf(ctx, fn, keys...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// XAck provides a mock function with given fields: ctx, stream, group, ids
func (_m *UniversalClient) XAck(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream, group)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XAck")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAdd provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XAdd(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAdd")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAddArgs) *redis.StringCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// XAutoClaim provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XAutoClaim(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaim")
	}

	var r0 *redis.XAutoClaimCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XAutoClaimCmd)
		}
	}

	return r0
}

// XAutoClaimJustID provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XAutoClaimJustID(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaimJustID")
	}

	var r0 *redis.XAutoClaimJustIDCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XAutoClaimJustIDCmd)
		}
	}

	return r0
}

// XClaim provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XClaim(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaim")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XClaimArgs) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XClaimJustID provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XClaimJustID(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaimJustID")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XClaimArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// XDel provides a mock function with given fields: ctx, stream, ids
func (_m *UniversalClient) XDel(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupCreate provides a mock function with given fields: ctx, stream, group, start
func (_m *UniversalClient) XGroupCreate(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupCreateConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *UniversalClient) XGroupCreateConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupCreateMkStream provides a mock function with given fields: ctx, stream, group, start
func (_m *UniversalClient) XGroupCreateMkStream(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateMkStream")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupDelConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *UniversalClient) XGroupDelConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDelConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupDestroy provides a mock function with given fields: ctx, stream, group
func (_m *UniversalClient) XGroupDestroy(ctx context.Context, stream string, group string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDestroy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupSetID provides a mock function with given fields: ctx, stream, group, start
func (_m *UniversalClient) XGroupSetID(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupSetID")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XInfoConsumers provides a mock function with given fields: ctx, key, group
func (_m *UniversalClient) XInfoConsumers(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
	ret := _m.Called(ctx, key, group)

	if len(ret) == 0 {
		panic("no return value specified for XInfoConsumers")
	}

	var r0 *redis.XInfoConsumersCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.XInfoConsumersCmd); ok {
		r0 = rf(ctx, key, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoConsumersCmd)
		}
	}

	return r0
}

// XInfoGroups provides a mock function with given fields: ctx, key
func (_m *UniversalClient) XInfoGroups(ctx context.Context, key string) *redis.XInfoGroupsCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoGroups")
	}

	var r0 *redis.XInfoGroupsCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.XInfoGroupsCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoGroupsCmd)
		}
	}

	return r0
}

// XInfoStream provides a mock function with given fields: ctx, key
func (_m *UniversalClient) XInfoStream(ctx context.Context, key string) *redis.XInfoStreamCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStream")
	}

	var r0 *redis.XInfoStreamCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.XInfoStreamCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoStreamCmd)
		}
	}

	return r0
}

// XInfoStreamFull provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) XInfoStreamFull(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStreamFull")
	}

	var r0 *redis.XInfoStreamFullCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.XInfoStreamFullCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoStreamFullCmd)
		}
	}

	return r0
}

// XLen provides a mock function with given fields: ctx, stream
func (_m *UniversalClient) XLen(ctx context.Context, stream string) *redis.IntCmd {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for XLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XPending provides a mock function with given fields: ctx, stream, group
func (_m *UniversalClient) XPending(ctx context.Context, stream string, group string) *redis.XPendingCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XPending")
	}

	var r0 *redis.XPendingCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.XPendingCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingCmd)
		}
	}

	return r0
}

// XPendingExt provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XPendingExt(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XPendingExt")
	}

	var r0 *redis.XPendingExtCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XPendingExtArgs) *redis.XPendingExtCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingExtCmd)
		}
	}

	return r0
}

// XRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *UniversalClient) XRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *UniversalClient) XRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRead provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XRead(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XRead")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XReadArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadGroup provides a mock function with given fields: ctx, a
func (_m *UniversalClient) XReadGroup(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XReadGroup")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XReadGroupArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadStreams provides a mock function with given fields: ctx, streams
func (_m *UniversalClient) XReadStreams(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
	_va := make([]interface{}, len(streams))
	for _i := range streams {
		_va[_i] = streams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XReadStreams")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, streams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XRevRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *UniversalClient) XRevRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRevRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRevRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *UniversalClient) XRevRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRevRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XTrimMaxLen provides a mock function with given fields: ctx, key, maxLen
func (_m *UniversalClient) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMaxLenApprox provides a mock function with given fields: ctx, key, maxLen, limit
func (_m *UniversalClient) XTrimMaxLenApprox(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLenApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMinID provides a mock function with given fields: ctx, key, minID
func (_m *UniversalClient) XTrimMinID(ctx context.Context, key string, minID string) *redis.IntCmd {
	ret := _m.Called(ctx, key, minID)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, minID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimMinIDApprox provides a mock function with given fields: ctx, key, minID, limit
func (_m *UniversalClient) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, minID, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinIDApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, minID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAdd provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZAdd(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddArgs provides a mock function with given fields: ctx, key, args
func (_m *UniversalClient) ZAddArgs(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZAddArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddArgsIncr provides a mock function with given fields: ctx, key, args
func (_m *UniversalClient) ZAddArgsIncr(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgsIncr")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZAddArgs) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZAddGT provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZAddGT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddGT")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddLT provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZAddLT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddLT")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNX provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZAddNX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXX provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZAddXX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCard provides a mock function with given fields: ctx, key
func (_m *UniversalClient) ZCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ZCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCount provides a mock function with given fields: ctx, key, min, max
func (_m *UniversalClient) ZCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZDiff provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) ZDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *UniversalClient) ZDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZDiffWithScores provides a mock function with given fields: ctx, keys
func (_m *UniversalClient) ZDiffWithScores(ctx context.Context, keys ...string) *redis.ZSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZIncrBy provides a mock function with given fields: ctx, key, increment, member
func (_m *UniversalClient) ZIncrBy(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, increment, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrBy")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, increment, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZInter provides a mock function with given fields: ctx, store
func (_m *UniversalClient) ZInter(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ZStore) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZInterCard provides a mock function with given fields: ctx, limit, keys
func (_m *UniversalClient) ZInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZInterCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, limit, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZInterStore provides a mock function with given fields: ctx, destination, store
func (_m *UniversalClient) ZInterStore(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(ctx, destination, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZInterWithScores provides a mock function with given fields: ctx, store
func (_m *UniversalClient) ZInterWithScores(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ZStore) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZLexCount provides a mock function with given fields: ctx, key, min, max
func (_m *UniversalClient) ZLexCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZLexCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZMPop provides a mock function with given fields: ctx, order, count, keys
func (_m *UniversalClient) ZMPop(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, order, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZMPop")
	}

	var r0 *redis.ZSliceWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...string) *redis.ZSliceWithKeyCmd); ok {
		r0 = rf(ctx, order, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceWithKeyCmd)
		}
	}

	return r0
}

// ZMScore provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZMScore(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZMScore")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// ZPopMax provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) ZPopMax(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMax")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZPopMin provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) ZPopMin(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMin")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRandMember provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) ZRandMember(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for ZRandMember")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRandMemberWithScores provides a mock function with given fields: ctx, key, count
func (_m *UniversalClient) ZRandMemberWithScores(ctx context.Context, key string, count int) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for ZRandMemberWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRange provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) ZRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeArgs provides a mock function with given fields: ctx, z
func (_m *UniversalClient) ZRangeArgs(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgs")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZRangeArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeArgsWithScores provides a mock function with given fields: ctx, z
func (_m *UniversalClient) ZRangeArgsWithScores(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgsWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZRangeArgs) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *UniversalClient) ZRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *UniversalClient) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *UniversalClient) ZRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRangeStore provides a mock function with given fields: ctx, dst, z
func (_m *UniversalClient) ZRangeStore(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
	ret := _m.Called(ctx, dst, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZRangeArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, dst, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) ZRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRank provides a mock function with given fields: ctx, key, member
func (_m *UniversalClient) ZRank(ctx context.Context, key string, member string) *redis.IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRankWithScore provides a mock function with given fields: ctx, key, member
func (_m *UniversalClient) ZRankWithScore(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRankWithScore")
	}

	var r0 *redis.RankWithScoreCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.RankWithScoreCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.RankWithScoreCmd)
		}
	}

	return r0
}

// ZRem provides a mock function with given fields: ctx, key, members
func (_m *UniversalClient) ZRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByLex provides a mock function with given fields: ctx, key, min, max
func (_m *UniversalClient) ZRemRangeByLex(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByLex")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByRank provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) ZRemRangeByRank(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByScore provides a mock function with given fields: ctx, key, min, max
func (_m *UniversalClient) ZRemRangeByScore(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByScore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRevRange provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) ZRevRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *UniversalClient) ZRevRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *UniversalClient) ZRevRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *UniversalClient) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *UniversalClient) ZRevRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRank provides a mock function with given fields: ctx, key, member
func (_m *UniversalClient) ZRevRank(ctx context.Context, key string, member string) *redis.IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRevRankWithScore provides a mock function with given fields: ctx, key, member
func (_m *UniversalClient) ZRevRankWithScore(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRankWithScore")
	}

	var r0 *redis.RankWithScoreCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.RankWithScoreCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.RankWithScoreCmd)
		}
	}

	return r0
}

// ZScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *UniversalClient) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for ZScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ZScore provides a mock function with given fields: ctx, key, member
func (_m *UniversalClient) ZScore(ctx context.Context, key string, member string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZScore")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZUnion provides a mock function with given fields: ctx, store
func (_m *UniversalClient) ZUnion(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZStore) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZUnionStore provides a mock function with given fields: ctx, dest, store
func (_m *UniversalClient) ZUnionStore(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(ctx, dest, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(ctx, dest, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZUnionWithScores provides a mock function with given fields: ctx, store
func (_m *UniversalClient) ZUnionWithScores(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZStore) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// NewUniversalClient creates a new instance of UniversalClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUniversalClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *UniversalClient {
	mock := &UniversalClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
